# 海关证件识别与鉴伪系统 - 代码文档 V1.0

## 文档信息

- **版本**: V1.0
- **生成日期**: 2026-01-08
- **项目名称**: 海关证件识别与鉴伪系统 (GPU版本)
- **文档类型**: 技术实现文档

---

## 目录

1. [系统整体架构](#系统整体架构)
2. [模块1: 证件检测与OCR识别](#模块1-证件检测与ocr识别)
3. [模块2: 证件语义结构化信息提取](#模块2-证件语义结构化信息提取)
4. [模块3: 证件鉴伪系统](#模块3-证件鉴伪系统)
5. [模块4: Web服务系统](#模块4-web服务系统)
6. [配置文件](#配置文件)
7. [后续改进建议](#后续改进建议)

---

## 系统整体架构

### 系统流程图

```
输入图片/PDF
    ↓
[模块1: 检测与OCR]
    ├─ 证件类型识别
    ├─ OCR文本提取
    └─ 边界框检测
    ↓
[模块2: 信息提取]
    └─ 结构化字段提取
    ↓
[模块3: 鉴伪检测]
    ├─ 图像层分析 (40%)
    ├─ 文本层分析 (35%)
    └─ 结构层分析 (25%)
    ↓
输出结果
    ├─ 证件类型
    ├─ 结构化信息
    ├─ 真伪评分
    └─ 风险等级
```

### 核心技术栈

| 技术 | 用途 | 说明 |
|------|------|------|
| PaddleOCR | OCR文字识别 | 支持中英文，文本方向检测 |
| OpenCV | 图像处理 | 图像读取、预处理、特征提取 |
| PyTorch | 深度学习框架 | CNN伪造检测模型 |
| PyMuPDF (fitz) | PDF处理 | PDF转图像 |
| Flask | Web框架 | REST API服务 |
| NumPy | 数值计算 | 数组运算、统计分析 |

---

## 模块1: 证件检测与OCR识别

### 文件: `module1_detection.py`

### 核心类: `CertificateDetector`

#### 1.1 初始化方法

```python
def __init__(self):
    self.ocr = PaddleOCR(**OCR_CONFIG)
```

**配置说明**:
- `use_gpu`: False - 使用CPU模式避免多进程CUDA初始化问题
- `use_textline_orientation`: True - 启用文本方向检测
- `lang`: 'ch' - 中文支持

#### 1.2 主检测流程: `detect_certificate(image_path)`

**输入**: 图片或PDF文件路径
**输出**: 检测结果字典

```python
{
    'has_certificate': bool,      # 是否存在证件
    'certificate_type': str,       # 证件类型: 'animal'/'plant'/'food'
    'confidence': float,           # 置信度 0-1
    'bbox': [x, y, w, h],         # 证件边界框
    'ocr_result': object,          # 原始OCR结果
    'ocr_text': str               # 提取的文本
}
```

**处理流程**:

```
步骤1: 文件类型判断
  ├─ PDF文件 → _convert_pdf_to_image()
  │   └─ 使用PyMuPDF将第一页转为图像(放大2倍)
  └─ 图片文件 → numpy方式读取(支持中文路径)

步骤2: OCR识别
  └─ ocr.ocr(image_path, cls=False)

步骤3: 文本提取
  └─ _extract_ocr_text(ocr_result)
      ├─ 兼容PaddleX OCRResult对象
      └─ 兼容传统嵌套列表格式

步骤4: 证件存在性检测
  └─ _detect_certificate_presence(image, ocr_text)
      ├─ 关键词检测
      ├─ 尺寸合理性检查
      └─ 文本长度检查

步骤5: 证件类型分类
  └─ _classify_certificate_type(ocr_text)
      └─ 分层关键词匹配策略

步骤6: 边界框检测
  └─ _detect_certificate_bbox(image, ocr_result)
      └─ 计算所有文本框的最小外接矩形
```

#### 1.3 关键算法详解

##### 1.3.1 PDF转图像算法

**方法**: `_convert_pdf_to_image(pdf_path)`

```python
# 1. 打开PDF
doc = fitz.open(pdf_path)
page = doc[0]

# 2. 设置放大倍数提高分辨率
zoom = 2.0
mat = fitz.Matrix(zoom, zoom)

# 3. 渲染为图像
pix = page.get_pixmap(matrix=mat)

# 4. 转换为OpenCV格式
img_data = pix.tobytes("ppm")
nparr = np.frombuffer(img_data, np.uint8)
image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
```

**技术要点**:
- 使用2倍放大确保OCR识别精度
- PPM格式无损转换
- 支持中文路径

##### 1.3.2 OCR文本提取算法

**方法**: `_extract_ocr_text(ocr_result)`

**支持两种OCR结果格式**:

**格式1: PaddleX OCRResult对象**
```python
if hasattr(result_obj, 'json'):
    result_json = result_obj.json
    # {'res': {'rec_texts': [...], 'dt_polys': [...]}}
    texts = result_json['res']['rec_texts']
```

**格式2: 传统嵌套列表**
```python
# [[[[x1,y1],[x2,y2]...], [text, confidence]], ...]
for line_result in page_result:
    text_info = line_result[1]
    text = text_info[0]
```

##### 1.3.3 证件存在性检测算法

**方法**: `_detect_certificate_presence(image, ocr_text)`

```python
# 1. 关键词检测
keywords = [
    '证书', '证明', 'certificate', 'CERTIFICATE',
    '检疫', 'quarantine', 'QUARANTINE',
    '卫生', 'health', 'HEALTH',
    '植物', 'plant', 'PLANT', 'phytosanitary',
    '动物', 'animal', 'ANIMAL', 'veterinary',
    '食品', 'food', 'FOOD'
]
has_keywords = any(kw in ocr_text for kw in keywords)

# 2. 尺寸合理性检查
height, width = image.shape[:2]
reasonable_size = (width > 500 and height > 300)

# 3. 文本长度检查
has_enough_text = len(ocr_text) > 50

# 4. 综合判断 (宽松策略)
return has_keywords or has_enough_text
```

**设计理念**: 宽松策略降低误判率，宁可漏判也不要误判

##### 1.3.4 证件类型分类算法

**方法**: `_classify_certificate_type(ocr_text)`

**分层匹配策略**:

```python
# 优先级1: 水产品(特殊类别)
aquatic_keywords = ['水产', '水产品', 'aquatic', 'fishery',
                    'seafood', '虾', '蟹', '贝类']
if aquatic_count > 0:
    return 'food', min(0.8, 0.3 + aquatic_count * 0.1)

# 优先级2: 统计各类别关键词数量
animal_keywords = ['动物', 'animal', '肉类', '燕窝', 'meat']
plant_keywords = ['植物', 'plant', 'phytosanitary', '木材', '种子']
food_keywords = ['食品', '中药材', '坚果', '食用', 'food']

# 计算匹配数量
animal_count = sum(1 for kw in animal_keywords if kw in ocr_text)
plant_count = sum(1 for kw in plant_keywords if kw in ocr_text)
food_count = sum(1 for kw in food_keywords if kw in ocr_text)

# 返回数量最多的类型
confidence = max_count / total_keywords_of_type
```

**置信度计算**:
```python
confidence = matched_count / total_keywords_in_category
```

##### 1.3.5 边界框检测算法

**方法**: `_detect_certificate_bbox(image, ocr_result)`

```python
# 1. 收集所有文本框的坐标点
all_points = []
for each ocr_result:
    all_points.extend(bbox_coordinates)

# 2. 计算最小外接矩形
points = np.array(all_points, dtype=np.float32)
x_min = int(np.min(points[:, 0]))
y_min = int(np.min(points[:, 1]))
x_max = int(np.max(points[:, 0]))
y_max = int(np.max(points[:, 1]))

# 3. 返回 [x, y, width, height] 格式
return [x_min, y_min, x_max - x_min, y_max - y_min]
```

#### 1.4 辅助方法

| 方法 | 功能 | 说明 |
|------|------|------|
| `extract_certificate_region()` | 提取证件区域 | 根据边界框裁剪图像 |
| `_convert_pdf_to_image()` | PDF转图像 | 支持中文路径 |

---

## 模块2: 证件语义结构化信息提取

### 文件: `module2_extraction.py`

### 核心类: `CertificateExtractor`

#### 2.1 初始化方法

定义三类**正则表达式模式库**:

```python
# 1. 通用字段模式 (所有证书类型)
self.field_patterns = {
    'certificate_number': [...],  # 证书编号
    'issue_date': [...],          # 签发日期
    'issuer': [...],              # 签发机构
    'origin': [...],              # 产地
    'destination': [...],         # 目的地
    'goods_name': [...],          # 货物名称
    'goods_quantity': [...],      # 货物数量
}

# 2. 植物证书特有字段
self.plant_patterns = {
    'botanical_name': [...],      # 植物学名
    'treatment': [...],           # 处理方式
    'treatment_date': [...],      # 处理日期
}

# 3. 动物证书特有字段
self.animal_patterns = {
    'species': [...],             # 物种
    'veterinary_info': [...],     # 兽医信息
}

# 4. 食品证书特有字段
self.food_patterns = {
    'production_date': [...],     # 生产日期
    'expiry_date': [...],         # 有效期
    'batch_number': [...],        # 批号
}
```

#### 2.2 主提取流程: `extract(ocr_text, certificate_type)`

```python
result = {
    'certificate_type': str,
    'extracted_fields': dict,
    'raw_text': str
}

# 步骤1: 提取通用字段
result['extracted_fields'].update(
    _extract_fields(ocr_text, self.field_patterns)
)

# 步骤2: 根据类型提取特定字段
if certificate_type == 'plant':
    result['extracted_fields'].update(
        _extract_fields(ocr_text, self.plant_patterns)
    )
elif certificate_type == 'animal':
    result['extracted_fields'].update(
        _extract_fields(ocr_text, self.animal_patterns)
    )
elif certificate_type == 'food':
    result['extracted_fields'].update(
        _extract_fields(ocr_text, self.food_patterns)
    )

# 步骤3: 清理字段
result['extracted_fields'] = _clean_fields(result['extracted_fields'])

# 步骤4: 提取额外信息
result['additional_info'] = _extract_additional_info(ocr_text, certificate_type)
```

#### 2.3 关键算法详解

##### 2.3.1 正则表达式提取算法

**方法**: `_extract_fields(text, patterns)`

```python
extracted = {}
for field_name, pattern_list in patterns.items():
    value = None
    # 按优先级尝试多个模式
    for pattern in pattern_list:
        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
        if match:
            # 提取捕获组，如果没有捕获组则提取整个匹配
            value = match.group(1) if match.lastindex else match.group(0)
            break  # 匹配到就停止
    extracted[field_name] = value
return extracted
```

**典型正则模式示例**:

```python
# 证书编号
'certificate_number': [
    r'(?:Certificate\s+No|No\.|NO\.|Number|编号)[\.:\s：]*([A-Z0-9\-/]+)',
    r'\b([A-Z]{2,}\d{4,}[-/]\d+[-/]\d+)\b',
    r'(\d{4,}[-]\d{3}[-]\d{2,})',
]

# 签发日期
'issue_date': [
    r'(?:Date\s+Issued|签发日期|Issue\s+Date)[\.:\s：]*(\d{1,2}[-/.]\d{1,2}[-/.]\d{2,4})',
    r'(?:Date\s+Issued|签发日期)[\.:\s：]*(\d{4}[-/.]\d{1,2}[-/.]\d{1,2})',
]

# 货物名称
'goods_name': [
    r'(?:Name\s+of\s+product\s+and\s+quantit)[\.:\s：]*([^\n]+)',
    r'(?:Product|货物名称|商品名称)[\.:\s：]*([^\n]+)',
    r'This\s+cosignment\s+of\s+(\w+)',
]
```

##### 2.3.2 字段清理算法

**方法**: `_clean_fields(fields)`

```python
cleaned = {}
for key, value in fields.items():
    if value:
        # 1. 去除首尾空白
        value = value.strip()

        # 2. 合并多余空格
        value = re.sub(r'\s+', ' ', value)

        # 3. 去除冒号等分隔符
        value = value.strip(':：')

        # 4. 过滤过短或纯空白的值
        if len(value) < 2 or value.isspace():
            value = None

    cleaned[key] = value
return cleaned
```

##### 2.3.3 额外信息提取算法

**方法**: `_extract_additional_info(text, certificate_type)`

```python
additional = {}

# 1. 关键词提取
keywords = _extract_keywords(text, certificate_type)
additional['keywords'] = keywords

# 2. 国家/地区提取
countries = [
    'China', 'Lao', 'Laos', 'Vietnam', 'Thailand', 'Myanmar',
    'Cambodia', 'Malaysia', 'Singapore', 'Indonesia', ...
]
found_countries = [c for c in countries if re.search(r'\b' + c + r'\b', text, re.IGNORECASE)]
additional['countries'] = found_countries

# 3. 数字信息提取
numbers = re.findall(r'\b\d{4,}\b', text)
additional['numbers'] = numbers[:5]  # 只保留前5个
```

#### 2.4 数据库格式化

**方法**: `format_for_database(extracted_data)`

```python
db_format = {
    'certificate_type': str,
    'certificate_number': str,
    'issuer': str,
    'issue_date': str,
    'goods_name': str,
    'goods_quantity': str,
    'origin': str,
    'destination': str,
    'ocr_text': str,
    'additional_info': json_string
}
```

---

## 模块3: 证件鉴伪系统

### 文件: `module3_forgery.py`

### 三层检测架构

```
┌─────────────────────────────────────────────┐
│     ForgeryDetectionSystem (主控类)          │
│                                             │
│  ┌─────────────────────────────────────┐    │
│  │  ImageForgeryDetector (图像层)      │    │
│  │  权重: 40%                          │    │
│  │  - 拼接伪影检测                     │    │
│  │  - 分辨率一致性检测                 │    │
│  │  - JPEG压缩伪影检测                 │    │
│  │  - 边缘异常检测                     │    │
│  └─────────────────────────────────────┘    │
│                                             │
│  ┌─────────────────────────────────────┐    │
│  │  TextConsistencyChecker (文本层)    │    │
│  │  权重: 35%                          │    │
│  │  - 日期逻辑校验                     │    │
│  │  - 术语规范性检查                   │    │
│  │  - 字段完整性检查                   │    │
│  │  - 文本格式检查                     │    │
│  └─────────────────────────────────────┘    │
│                                             │
│  ┌─────────────────────────────────────┐    │
│  │  StructureValidator (结构层)        │    │
│  │  权重: 25%                          │    │
│  │  - 文本框数量检查                   │    │
│  │  - 布局规范性检查                   │    │
│  │  - 文本对齐检查                     │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

### 3.1 图像层检测: `ImageForgeryDetector`

#### 3.1.1 CNN模型结构

```python
class SimpleForgeryNet(nn.Module):
    def __init__(self):
        super(SimpleForgeryNet, self).__init__()

        # 特征提取层
        self.features = nn.Sequential(
            nn.Conv2d(3, 32, 3, padding=1),  # 输入: 3通道彩色图像
            nn.ReLU(),
            nn.MaxPool2d(2, 2),              # 下采样
            nn.Conv2d(32, 64, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),
            nn.Conv2d(64, 128, 3, padding=1),
            nn.ReLU(),
            nn.AdaptiveAvgPool2d((1, 1))     # 全局平均池化
        )

        # 分类器
        self.classifier = nn.Sequential(
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.5),                 # 防止过拟合
            nn.Linear(64, 1),
            nn.Sigmoid()                     # 输出0-1概率
        )
```

*(注: 当前为简化模型，实际应用需要在大规模数据集上训练)*

#### 3.1.2 拼接伪影检测

**方法**: `_detect_splicing(image)`

**原理**: Error Level Analysis (ELA) - 不同来源的图像块压缩特性不同

```python
# 1. 将图像划分为64x64网格
grid_size = 64
scores = []

for i in range(0, h - grid_size, grid_size):
    for j in range(0, w - grid_size, grid_size):
        block = image[i:i+grid_size, j:j+grid_size]
        # 2. 计算每个块的标准差
        std = np.std(block)
        scores.append(std)

# 3. 分析标准差之间的差异
score_std = np.std(scores)
splice_score = min(score_std / 100.0, 1.0)
```

**检测逻辑**:
- 正常图像: 各块标准差相近
- 拼接图像: 不同来源区域的标准差差异大

#### 3.1.3 分辨率不一致检测

**方法**: `_detect_resolution_inconsistency(image)`

**原理**: 拼接图像不同区域的清晰度可能不同

```python
# 1. 使用拉普拉斯算子计算清晰度
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
laplacian = cv2.Laplacian(gray, cv2.CV_64F)

# 2. 分块计算清晰度方差
grid_size = 100
sharpness_scores = []

for i in range(0, h - grid_size, grid_size):
    for j in range(0, w - grid_size, grid_size):
        block = laplacian[i:i+grid_size, j:j+grid_size]
        sharpness = np.var(block)
        sharpness_scores.append(sharpness)

# 3. 分析清晰度差异
score_std = np.std(sharpness_scores)
mean_score = np.mean(sharpness_scores)
resolution_score = min(score_std / mean_score, 1.0) if mean_score > 0 else 0
```

**检测逻辑**:
- 正常图像: 各区域清晰度一致
- 拼接图像: 清晰度方差大

#### 3.1.4 JPEG压缩伪影检测

**方法**: `_detect_jpeg_artifacts(image)`

**原理**: JPEG使用8x8块编码，多次压缩或不同来源拼接会导致块边界异常

```python
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
block_size = 8
discontinuities = []

# 1. 计算8的倍数位置的梯度(水平方向)
h, w = gray.shape
for i in range(block_size, h - block_size, block_size):
    diff = np.abs(gray[i, :] - gray[i-1, :])
    discontinuities.append(np.mean(diff))

# 2. 计算8的倍数位置的梯度(垂直方向)
for j in range(block_size, w - block_size, block_size):
    diff = np.abs(gray[:, j] - gray[:, j-1])
    discontinuities.append(np.mean(diff))

# 3. 计算平均不连续性
jpeg_score = min(np.mean(discontinuities) / 50.0, 1.0)
```

**检测逻辑**:
- 正常图像: 块边界梯度平滑
- 异常图像: 块边界梯度突增

#### 3.1.5 边缘异常检测

**方法**: `_detect_edge_anomalies(image)`

```python
# 1. 使用Canny边缘检测
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
edges = cv2.Canny(gray, 100, 200)

# 2. 计算边缘密度
edge_density = np.sum(edges > 0) / edges.size

# 3. 判断是否异常
# 正常证件的边缘密度在合理范围(1%-30%)
if edge_density < 0.01 or edge_density > 0.3:
    edge_score = min(abs(edge_density - 0.15) / 0.15, 1.0)
else:
    edge_score = 0.0
```

**检测逻辑**:
- 边缘密度过低: 内容缺失
- 边缘密度过高: 噪声过多或扫描质量差

### 3.2 文本层检测: `TextConsistencyChecker`

#### 3.2.1 标准术语库

```python
self.standard_terms = {
    'plant': [
        'phytosanitary', 'botanical', 'quarantine', 'plant',
        'ministry of agriculture', 'department of agriculture'
    ],
    'animal': [
        'veterinary', 'animal', 'quarantine', 'inspection',
        'ministry of agriculture', 'health certificate'
    ],
    'food': [
        'food', 'sanitary', 'health', 'inspection',
        'certificate', 'quarantine'
    ]
}
```

#### 3.2.2 日期逻辑检查

**方法**: `_check_date_logic(fields)`

```python
date_fields = ['issue_date', 'inspection_date', 'production_date', 'expiry_date']
found_dates = sum(1 for field in date_fields if fields.get(field))

if found_dates == 0:
    return 0.7  # 没有日期字段是可疑的
else:
    return 0.0  # TODO: 可扩展日期范围校验、逻辑关系校验
```

#### 3.2.3 术语规范性检查

**方法**: `_check_terminology(text, cert_type)`

```python
standard = self.standard_terms[cert_type]
found = sum(1 for term in standard if term in text.lower())

# 至少应该包含30%的标准术语
expected_count = len(standard) * 0.3
if found < expected_count:
    return 0.6
else:
    return 0.0
```

#### 3.2.4 字段完整性检查

**方法**: `_check_field_completeness(fields)`

```python
required_fields = ['issuer', 'goods_name']
missing = sum(1 for field in required_fields if not fields.get(field))

completeness_score = missing / len(required_fields)
```

#### 3.2.5 文本格式检查

**方法**: `_check_text_format(text)`

```python
# 1. 检查文本长度
if len(text) < 100:
    return 0.8  # 文本太短可疑

# 2. 检查字母字符比例
alpha_ratio = sum(c.isalpha() for c in text) / len(text)
if alpha_ratio < 0.3:
    return 0.6  # 字母字符太少可疑

return 0.0
```

### 3.3 结构层检测: `StructureValidator`

#### 3.3.1 文本框数量检查

**方法**: `_check_text_count(ocr_result, cert_type)`

```python
# 从OCR结果提取文本框数量
text_count = len(ocr_result['rec_texts'])

# 正常证书应该有20-100个文本框
if text_count < 20:
    return 0.7  # 太少可疑
elif text_count > 150:
    return 0.5  # 过多可疑
else:
    return 0.0
```

#### 3.3.2 布局规范性检查

**方法**: `_check_layout(ocr_result, bbox)`

```python
if bbox and len(bbox) == 4:
    x, y, w, h = bbox
    aspect_ratio = w / h if h > 0 else 0

    # 证书通常是横向的，宽高比约在1.2-1.8之间
    if aspect_ratio < 0.8 or aspect_ratio > 2.5:
        return 0.6  # 宽高比异常

return 0.0
```

#### 3.3.3 文本对齐检查

**方法**: `_check_alignment(ocr_result)`

```python
# 当前为简化实现，返回0
# TODO: 可扩展实现
# - 检测文本框是否水平对齐
# - 检测行间距是否均匀
return 0.0
```

### 3.4 特征融合与风险判定

**方法**: `ForgeryDetectionSystem.detect()`

```python
# 1. 图像层检测
image_result = self.image_detector.detect(image_path)
image_score = image_result['forgery_score']

# 2. 文本层检测
text_result = self.text_checker.check(ocr_text, extracted_fields, certificate_type)
text_score = text_result['consistency_score']

# 3. 结构层检测
structure_result = self.structure_validator.validate(ocr_result, certificate_type, bbox)
structure_score = structure_result['structure_score']

# 4. 加权融合
final_score = (
    image_score * 0.4 +
    text_score * 0.35 +
    structure_score * 0.25
)

# 5. 风险等级判定
if final_score < 0.5:
    forgery_risk = 'genuine'      # 真实
    recommendation = '证件真实性较高，建议通过'
elif final_score < 0.8:
    forgery_risk = 'suspicious'   # 疑似
    recommendation = '证件存在可疑特征，建议人工复核'
else:
    forgery_risk = 'forged'       # 伪造
    recommendation = '证件伪造风险高，建议拒绝'
```

**权重分配**:
- 图像层 40%: 物理伪造痕迹最直接
- 文本层 35%: 逻辑矛盾能快速识别
- 结构层 25%: 布局异常作为辅助判断

---

## 模块4: Web服务系统

### 文件: `app.py`

### 4.1 Flask API架构

```
GET  /               → HTML交互界面
POST /api/analyze    → 证件分析主接口
GET  /api/health     → 健康检查
```

### 4.2 主分析流程: `analyze_certificate()`

```python
# 输入: 上传的文件
# 输出: JSON格式的分析结果

@app.route('/api/analyze', methods=['POST'])
def analyze_certificate():
    # ===== 步骤1: 文件验证与保存 =====
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': '没有文件上传'})

    file = request.files['file']

    # 检查文件类型
    if not allowed_file(file.filename):
        return jsonify({'success': False, 'error': '不支持的文件类型'})

    # 保存文件 (处理中文路径)
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
    filename = f"{timestamp}{ext.lower()}"
    filepath = UPLOAD_FOLDER / filename
    file.save(str(filepath))

    # ===== 步骤2: 证件检测 =====
    detection_result = detector.detect_certificate(str(filepath))

    if not detection_result['has_certificate']:
        return jsonify({
            'success': False,
            'error': '未检测到证件，请确认上传的是证件图片'
        })

    # ===== 步骤3: 信息提取 =====
    extraction_result = extractor.extract(
        detection_result['ocr_text'],
        detection_result['certificate_type']
    )

    # ===== 步骤4: 鉴伪检测 =====
    forgery_result = forgery_system.detect(
        str(filepath),
        detection_result['ocr_result'],
        detection_result['ocr_text'],
        extraction_result['extracted_fields'],
        detection_result['certificate_type'],
        detection_result['bbox']
    )

    # ===== 步骤5: 返回结果 =====
    result = {
        'certificate_type': detection_result['certificate_type'],
        'confidence': detection_result['confidence'],
        'extracted_fields': extraction_result['extracted_fields'],
        'forgery_result': {
            'forgery_score': forgery_result['forgery_score'],
            'forgery_risk': forgery_result['forgery_risk'],
            'image_score': forgery_result['image_score'],
            'text_score': forgery_result['text_score'],
            'structure_score': forgery_result['structure_score'],
            'image_analysis': forgery_result['image_analysis'],
            'text_analysis': forgery_result['text_analysis'],
            'structure_analysis': forgery_result['structure_analysis'],
            'recommendation': forgery_result['recommendation']
        }
    }

    return jsonify({'success': True, 'result': result})
```

### 4.3 前端界面

**技术特点**:
- 响应式设计，支持拖拽上传
- 实时显示处理进度
- 三部分展示结果:
  1. 基本信息 (证件类型、编号、签发机构等)
  2. 货物信息 (名称、数量、产地、目的地)
  3. 鉴伪检测 (风险等级、综合评分、详细分析)

---

## 配置文件

### 文件: `config.py`

### 5.1 OCR配置

```python
OCR_CONFIG = {
    'use_gpu': False,                 # CPU模式避免多进程问题
    'use_textline_orientation': True, # 启用文本方向检测
    'lang': 'ch'                      # 中文支持
}
```

### 5.2 鉴伪阈值配置

```python
FORGERY_THRESHOLDS = {
    'genuine': 0.5,      # <0.5 判定为真实
    'suspicious': 0.8,   # 0.5-0.8 判定为疑似
    # >0.8 判定为伪造
}
```

### 5.3 上传文件配置

```python
UPLOAD_FOLDER = BASE_DIR / 'uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'pdf'}
MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
```

### 5.4 证书类型配置

```python
CERTIFICATE_TYPES = {
    'animal': {
        'name': '动物证书',
        'regions': ['亚洲', '北美洲', '南美洲', '大洋洲', '欧洲', '非洲']
    },
    'plant': {
        'name': '植物证书',
        'regions': ['亚洲', '北美洲', '南美洲', '大洋洲', '欧洲', '非洲']
    },
    'food': {
        'name': '食品证书',
        'categories': ['中药材证书', '干坚果证书', '水产品证书', '燕窝证书', '肉类证书']
    }
}
```

---

## 后续改进建议

### 6.1 模块1改进方向

| 优先级 | 改进项 | 说明 |
|--------|--------|------|
| 高 | 深度学习证件检测 | 引入YOLO模型进行证件区域精确定位 |
| 中 | 多页PDF支持 | 当前只处理第一页，可扩展支持多页合并 |
| 中 | 图像预处理优化 | 添加去噪、倾斜校正、对比度增强 |
| 低 | OCR结果后处理 | 纠错、上下文校验 |

**具体实现建议**:
```python
# 建议使用YOLOv8进行证件检测
from ultralytics import YOLO
model = YOLO('certificate_detector.pt')
results = model(image)
bbox = results[0].boxes.xyxy[0]  # 获取证件边界框
```

### 6.2 模块2改进方向

| 优先级 | 改进项 | 说明 |
|--------|--------|------|
| 高 | NLP模型抽取 | 引入LLM进行语义理解和字段抽取 |
| 高 | 字段验证规则 | 证书编号格式校验、日期范围校验 |
| 中 | 多语言支持 | 扩展英文、泰文、越南文等 |
| 中 | 关系抽取 | 抽取字段间的语义关系 |

**具体实现建议**:
```python
# 使用LLM进行字段抽取
from transformers import AutoModelForCausalLM, AutoTokenizer

model = AutoModelForCausalLM.from_pretrained("Qwen/Qwen-7B")
prompt = f"""
从以下证书文本中提取结构化信息:
{ocr_text}

请提取: 证书编号、签发日期、货物名称等字段
"""
```

### 6.3 模块3改进方向

| 优先级 | 改进项 | 说明 |
|--------|--------|------|
| 高 | 训练专用CNN模型 | 使用真实/伪造证件数据集训练 |
| 高 | 打印质量检测 | 检测分辨率、DPI、打印方式 |
| 中 | 印章真伪识别 | 检测印章的物理特征和数字特征 |
| 中 | 签名验证 | 笔迹分析、签名比对 |
| 中 | 更多图像特征 | 噪声模式、色彩一致性、光照分析 |

**具体实现建议**:
```python
# 训练CNN伪造检测模型
class AdvancedForgeryNet(nn.Module):
    def __init__(self):
        super().__init__()
        # 使用预训练ResNet作为特征提取器
        self.backbone = models.resnet50(pretrained=True)
        # 替换最后的分类层
        self.backbone.fc = nn.Sequential(
            nn.Linear(2048, 512),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(512, 1),
            nn.Sigmoid()
        )
```

**印章检测示例**:
```python
# 使用HSV色彩空间检测红色印章
hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
# 红色范围
lower_red1 = np.array([0, 100, 100])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([160, 100, 100])
upper_red2 = np.array([180, 255, 255])

# 提取红色区域
mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
red_mask = cv2.bitwise_or(mask1, mask2)

# 形态学操作去噪
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
red_mask = cv2.morphologyEx(red_mask, cv2.MORPH_CLOSE, kernel)

# 查找印章轮廓
contours, _ = cv2.findContours(red_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
```

### 6.4 系统级优化

| 优先级 | 改进项 | 说明 |
|--------|--------|------|
| 高 | 数据库集成 | 存储历史记录、统计分析 |
| 高 | 批量处理功能 | 支持多文件同时处理 |
| 中 | 日志系统 | 详细记录处理过程、错误信息 |
| 中 | 缓存机制 | 缓存OCR结果提高速度 |
| 低 | 用户认证 | 多用户权限管理 |

**数据库设计示例**:
```sql
CREATE TABLE certificates (
    id INT PRIMARY KEY AUTO_INCREMENT,
    certificate_type VARCHAR(20),
    certificate_number VARCHAR(100),
    issuer VARCHAR(200),
    issue_date DATE,
    goods_name TEXT,
    forgery_score FLOAT,
    forgery_risk VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE processing_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    file_path VARCHAR(500),
    processing_time FLOAT,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6.5 性能优化建议

```python
# 1. 异步处理
from celery import Celery
app = Celery('tasks', broker='redis://localhost:6379')

@app.task
def process_certificate_async(file_path):
    # 耗时的处理逻辑
    result = detector.detect_certificate(file_path)
    return result

# 2. GPU加速
OCR_CONFIG = {
    'use_gpu': True,  # 启用GPU
    'gpu_mem': 2000   # 设置GPU内存
}

# 3. 结果缓存
from functools import lru_cache

@lru_cache(maxsize=100)
def get_cached_ocr_result(file_hash):
    return detector.detect_certificate(file_path)
```

---

## 附录

### A. 项目文件结构

```
credit/
├── app.py                      # Flask Web服务
├── config.py                   # 配置文件
├── module1_detection.py        # 证件检测模块
├── module2_extraction.py       # 信息提取模块
├── module3_forgery.py          # 鉴伪检测模块
├── gunicorn_config.py          # Gunicorn配置
├── start_server.sh             # 启动脚本
├── stop_server.sh              # 停止脚本
├── test_api.py                 # API测试脚本
├── test_pdf.py                 # PDF处理测试
├── test_pdf_detailed.py        # PDF详细测试
├── uploads/                    # 上传文件目录
├── books/                      # 训练数据集
│   ├── 动物证书/
│   ├── 植物证书/
│   └── 食品证书/
└── README.md                   # 项目说明
```

### B. 依赖库版本

```
paddleocr>=2.7.0
paddlepaddle>=2.5.0
opencv-python>=4.8.0
torch>=2.0.0
flask>=2.3.0
flask-cors>=4.0.0
pymupdf>=1.23.0
numpy>=1.24.0
Pillow>=10.0.0
gunicorn>=21.0.0
```

### C. API接口文档

#### POST /api/analyze

**请求**: multipart/form-data
- file: 图像文件 (支持 jpg, png, pdf)

**响应**: JSON
```json
{
  "success": true,
  "result": {
    "certificate_type": "plant",
    "confidence": 0.85,
    "extracted_fields": {
      "certificate_number": "12345",
      "issuer": "MINISTRY OF AGRICULTURE",
      "goods_name": "Wood products"
    },
    "forgery_result": {
      "forgery_score": 0.23,
      "forgery_risk": "genuine",
      "image_score": 0.15,
      "text_score": 0.30,
      "structure_score": 0.25,
      "recommendation": "证件真实性较高，建议通过"
    }
  }
}
```

---

**文档结束**

*本文档由自动化工具生成，详细记录了海关证件识别与鉴伪系统的所有模块实现逻辑*
